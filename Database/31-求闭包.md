---
title: 求闭包
tag: [解题套路]
category: 数据库
---

>上周刚考完数据库，当时就想着要把计算题题型整理一下，当时复习花了两天的时间，把题目按照题型归了一下类，看看别人的解析，加上自己的思考，整理了一套自己的做题方法，趁着还有记忆，整理一下，以便以后要用到。
>
>先讲闭包。这个是求其他的前提。

<!--more-->

**例：**关系模式 R（U，F），其中 U={A，B，C，D，E，I}，F={A→D，AB→E，BI→E，CD→I，E→C}，计算（AE）+。

**解：**

第一步：令 X={AE}，X（0）=AE。

第二步：求 X（1）。逐一扫描 F 集合中各个函数依赖，在 F 中找出左边是 AE 子集的函数依赖，其结果是：A→D，E→C。这是，F 中这两个函数依赖要**打上标记** (我通常是**打上√**，表示已经用过，后面不能用了)。于是 X（1）=AE∪DC=ACDE；

第三步：判断 X（1）是否等于 X（0）以及 X（1）是否等于 U。

在这里，X（1）≠ X（0），且 X（1）≠ U，所以在 F 中继续找出左边是 ACDE 子集的函数依赖，其结果是：CD→I。同样打上标记。于是 X（2）=ACDE∪I=ACDEI。(这里有一个注意点，∪**右边**的元素**只写左边没有的**)

继续判断，虽然 X（2）≠ X（1），但在 F 中未用过的函数依赖的左边属性**已没有** X（2）的子集，所以不必再计算下去，即（AE）+=ACDEI。

这里总结一下**解题套路**：

**第一步：**X（0）=X。

**第二步：**求 X（1）。就是在 F 中找，左边是 X（0）的元素子集的函数依赖，打上标记√。

**第三步：**判断 X（1）是否等于 X（0）以及 X（1）是否等于 U。

这里有**四种情况**：

**第一种：**X（i）= X（i-1），说明已经找到闭包。

**第二种：**X（i）≠ X（i-1）但是 X（i）= U，说明已经找到闭包。

**第三种：**都不相等，但是在 F 中未用过的函数依赖的左边属性**已没有** X（i）的子集，所以不必再计算下去，已经找到闭包。

**第四种：**都不相等，在 F 中未用过的函数依赖的左边属性**还有** X（i）的子集，重复执行。



<u>本文于 2018 年 5 月 26 日首发于 [CSDN](https://blog.csdn.net/Wonz5130/article/details/80464466)。</u>