---
title: 求最小依赖集
tag: [解题套路]
category: 数据库
---

>这个比较烦，要写好多好多好多 QAQ。 

<!--more-->

**例：**U=(A,B,C,D,E,G)   F={BG->C,BD->E,DG->C,ADG->BC,AG->B,B->D}，求 F 最小依赖集。

**解：**

**第一步：右边单一化。**

F1={BG->C,BD->E,DG->C,ADG->B,ADG->C,AG->B,B->D}

**第二步：逐个求，在去掉它的 F 中求闭包，如果包含右边属性，则表示这个函数依赖要去掉。**

BG->C：求 (BG)**+**=BCDEG，包含右边属性 C，所以去掉。

BD->E：(BD)**+**=BD，不包含右边 E，所以不用去掉。

DG->C：(DG)**+**=DG，也不用去掉。

ADG->B：(ADG)**+**=U，包含 B，所以去掉。

ADG->C：(ADG)**+** 包含 C，去掉。(在这里，求闭包的时候，**不能再用**前面去掉的函数依赖了，所以如果从后往前判断，可能不用去掉 ADG->B，所以最小依赖集**不唯一**，写出一个即可。)

AG->B：(AG)**+**=AG，不用去掉。

B->D：(B)**+**=B，不用去掉。

所以 F2={BD->E,DG->C,AG->B,B->D}

**第三步：对左边属性单一化，判断冗余，代替。**

BD->E：B->E，求 (B)**+**=BD，包含 D，所以 D 冗余。

​              D->E，求 (D)**+**=D，所以 B 不冗余。

​              所以用 B->E 代替 BD->E。

DG->C：D->C，(D)**+**=D，所以 G 不冗余。

​               G->C，(G)**+**=G，所以 D 不冗余。

AG->B：A->B，(A)**+**=A，所以 G 不冗余。

​              G->B，(G)**+**=G，所以 A 不冗余。

所以 Fm={B->E,DG->C,AG->B,B->D}。



<u>本文于 2018 年 5 月 26 日首发于 [CSDN](https://blog.csdn.net/Wonz5130/article/details/80465245)。</u>